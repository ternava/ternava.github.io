@string{aps = {American Physical Society,}}


@inproceedings{martinez2018software,
  abbr={SPLC18},
  bibtex_show={true},
  title={Software product line extraction from variability-rich systems: The Robocode case study},
  author={Martinez, Jabier and Tërnava, Xhevahire and Ziadi, Tewfik},
  booktitle={22nd International Systems and Software Product Line Conference-Volume 1},
  pages={132--142},
  year={2018},
  html = {https://doi.org/10.1145/3233027.3233038},
  doi = {10.1145/3233027.3233038},
  pdf={https://hal.sorbonne-universite.fr/hal-01832650/document},
  supp={https://github.com/but4reuse/RobocodeSPL_teaching},
  abstract = {The engineering of a Software Product Line (SPL), either by creating it from scratch or through the re-engineering of existing variants, it uses to be a project that spans several years with a high investment. It is often hard to analyse and quantify this investment, especially in the context of extractive SPL adoption when the related software variants are independently created by different developers following different system architectures and implementation conventions. This paper reports an experience on the creation of an SPL by re-engineering system variants implemented around an educational game called Robocode. The objective of this game is to program a bot (a battle tank) that battles against the bots of other developers. The world-wide Robocode community creates and maintains a large base of knowledge and implementations that are mainly organized in terms of features, although not presented as an SPL. Therefore, a group of master students analysed this variability-rich domain and extracted a Robocode SPL. We present the results of such extraction augmented with an analysis and a quantification regarding the spent time and effort. We believe that the results and the a-posteriori analysis can provide insights on global challenges on SPL adoption. We also provide all the elements to SPL educators to reproduce the teaching activity, and we make available this SPL to be used for any research purpose.},
}

@inproceedings{martinez2018feature,
  abbr={SPLC18},
  bibtex_show={true},
  title={Feature location benchmark with ArgoUML SPL},
  author={Martinez, Jabier and Ordonez, Nicolas and Tërnava, Xhevahire and Ziadi, Tewfik and Aponte, Jairo and Figueiredo, Eduardo and Valente, Marco},
  booktitle={22nd International Systems and Software Product Line Conference-Volume 2},
  year={2018},
  organization={ACM},
  html = {https://doi.org/10.1145/3233027.3236402},
  doi = {10.1145/3233027.3236402},
  pdf={https://hal.sorbonne-universite.fr/hal-01722316/document},
  supp={https://github.com/but4reuse/argouml-spl-benchmark},
  abstract = {Feature location is a traceability recovery activity to identify the implementation elements associated to a characteristic of a system. Besides its relevance for software maintenance of a single system, feature location in a collection of systems received a lot of attention as a first step to re-engineer system variants (created through clone-and-own) into a Software Product Line (SPL). In this context, the objective is to unambiguously identify the boundaries of a feature inside a family of systems to later create reusable assets from these implementation elements. Among all the case studies in the SPL literature, variants derived from ArgoUML SPL stands out as the most used one. However, the use of different settings, or the omission of relevant information (e.g., the exact configurations of the variants or the way the metrics are calculated), makes it difficult to reproduce or benchmark the different feature location techniques even if the same ArgoUML SPL is used. With the objective to foster the research area on feature location, we provide a set of common scenarios using ArgoUML SPL and a set of utils to obtain metrics based on the results of existing and novel feature location techniques.},
}

@inproceedings{ziadi2018teaching,
  abbr={SPLC18},
  bibtex_show={true},
  title={Teaching projects and research objectives in SPL extraction},
  author={Ziadi, Tewfik and Martinez, Jabier and Tërnava, Xhevahire},
  booktitle={22nd International Systems and Software Product Line Conference-Volume 2},
  pages={44--45},
  year={2018},
  html = {https://doi.org/10.1145/3236405.3237205},
  doi = {10.1145/3236405.3237205},
  pdf={https://dl.acm.org/doi/pdf/10.1145/3236405.3237205},
  abstract = {This year at SPLC we present a teaching and research project where a group of master students analysed a variability-rich domain and extracted an SPL (The Robocode SPL). We present the results of such extraction augmented with an analysis and a quantification regarding the time and effort spent. The research objective was to get and share data about an end-to-end SPL extraction which is usually unavailable in industrial cases because of their large size, complexity, and duration. We provide all the material to replicate, reproduce or extend the case study so it can be easily reused for teaching by anyone in our community. However, we were asking ourselves how can we leverage such case study for teaching to pursue research objectives. In this position paper, we aim to outline our initial ideas that we want to enrich with the others' viewpoints during SPLTea. Towards planning the settings of future teaching projects around this Robocode SPL case study, which can be the timely research objectives that we can identify? Can we involve others in planning this project in their institutions to get further relevant results?},
}

@inproceedings{ternava2017tracing,
  abbr={ICSR17},
  bibtex_show={true},
  title={Tracing imperfectly modular variability in software product line implementation},
  author={Tërnava, Xhevahire and Collet, Philippe},
  booktitle={16th International Conference on Software Reuse},
  pages={112--120},
  year={2017},
  organization={Springer},
  html = {https://doi.org/10.1007/978-3-319-56856-0_8},
  doi={10.1007/978-3-319-56856-0_8},
  pdf={https://hal.archives-ouvertes.fr/hal-01486216/document},
  abstract={abstract="When large software product lines are engineered, a combined set of traditional techniques, e.g., inheritance, design patterns, generic types, is likely to be used for realizing the variability at the implementation level. In these techniques the concept of feature, as a reusable unit, does not have a first-class representation in implementation, but still an imperfect form of modularization of variability can be achieved. We present in this paper a framework (i) to explicitly capture and document this imperfectly modular variability -- by several combined techniques -- in a dedicated variability model, and (ii) to establish trace links between this model and the variability model at the specification level. We report on the implementation of the framework through a domain specific language, and show the feasibility of the approach on a real feature-rich system."},
}

@inproceedings{ternava2017early,
  abbr={SPLC17},
  bibtex_show={true},
  title={Early consistency checking between specification and implementation variabilities},
  author={Tërnava, Xhevahire and Collet, Philippe},
  booktitle={21st International Systems and Software Product Line Conference-Volume A},
  pages={29--38},
  year={2017},
  html = {https://doi.org/10.1145/3106195.3106209},
  doi = {10.1145/3106195.3106209},
  pdf={https://hal.archives-ouvertes.fr/hal-01699878/document},
  code={https://github.com/ternava/Variability-CChecking},
  abstract = {In a software product line (SPL) engineering approach, the addressed variability in core-code assets must be consistent with the specified domain variability, usually captured in a variability model, e.g., a feature model. Currently, the support for checking such consistency is limited, mostly when a single variability implementation technique is used, e.g., preprocessors in C. In realistic SPLs, variability is implemented using a combined set of traditional techniques, e.g., inheritance, overloading, design patterns. An inappropriate choice and combination of such techniques become the source of variability inconsistencies. In this paper, we present a tooled approach to check the consistency of variability between the specification and implementation levels, when several variability implementation techniques are used together. The proposed method models the implemented variability in terms of variation points and variants, in a forest-like structure, and uses slicing to partially check the resulting propositional formulas at both levels. As a result, it offers an early and automatic detection of inconsistencies when the mapping of variability between both levels is ideal, and with a possible extension to 1 -- to -- m mapping. We implemented and successfully applied the approach in four case studies. Our implementation, publicly available, detects inconsistencies in a very short time, which makes possible to ensure consistency earlier in the development process.},
}

@inproceedings{ternava2017diversity,
  abbr={SPLC17},
  bibtex_show={true},
  title={On the diversity of capturing variability at the implementation level},
  author={Tërnava, Xhevahire and Collet, Philippe},
  booktitle={21st International Systems and Software Product Line Conference-Volume B},
  pages={81--88},
  year={2017},
  html = {https://doi.org/10.1145/3109729.3109733},
  doi = {10.1145/3109729.3109733},
  pdf={https://hal.archives-ouvertes.fr/hal-01699883/document},
  supp={https://github.com/ternava/expressions_spl/wiki},
  abstract = {In many Software product lines (SPLs), if domain variability can be properly specified in terms of features in a feature model (FM), their implementation in core-code assets is hard to capture and maintain, as there are different techniques to implement the variability. Even with an organization in variation points and variants, most of these techniques do not shape the code in terms of features, and inconsistencies appear when the variability evolves at one level with no co-evolution at the other. To help SPL architects, one possible solution is to be able to reconstruct the FM by capturing the variability in core-code assets, but different implementation techniques expose diverse characteristics, hampering the process. We study in this paper the diverse dimensions of the existing variability implementation techniques, and how they can be captured in an abstract way. We then categorize them regarding these dimensions in a single catalog, extending previous classifications of such techniques. We also briefly show how the characteristics of the techniques could help to better capture the implemented variability, opening some potential in reverse engineering processes.},
}

@phdthesis{ternava2017handling,
  abbr={Ph.D. Thesis},
  bibtex_show={true},
  title={Handling variability at the code level: modeling, tracing and checking consistency},
  author={Tërnava, Xhevahire},
  year={2017},
  school={Université Côte d'Azur},
  html={https://tel.archives-ouvertes.fr/tel-01720323/},
  pdf={https://tel.archives-ouvertes.fr/tel-01720323/document},
  abstract={When large software product lines are engineered, a combined set of traditional techniques, such as inheritance, or design patterns, is likely to be used for implementing variability. In these techniques, the concept of feature, as a reusable unit, does not have a first-class representation at the implementation level. Further, an inappropriate choice of techniques becomes the source of variability inconsistencies between the domain and the implemented variabilities. In this thesis, we study the diversity of the majority of variability implementation techniques and provide a catalog that covers an enriched set of them. Then, we propose a framework to explicitly capture and model, in a fragmented way, the variability implemented by several combined techniques into technical variability models. These models use variation points and variants, with their logical relation and binding time, to abstract the implementation techniques. We show how to extend the framework to trace features with their respective implementation. In addition, we use this framework and provide a tooled approach to check the consistency of the implemented variability. Our method uses slicing to partially check the corresponding propositional formulas at the domain and implementation levels in case of 1–to–m mapping. It offers an early and automatic detection of inconsistencies. As validation, we report on the implementation in Scala of the framework as an internal domain specific language, and of the consistency checking method. These implementations have been applied on a real feature-rich system and on three product line case studies, showing the feasibility of the proposed contributions.},
}

@inproceedings{mortara2019symfinder,
  abbr={SPLC19},
  bibtex_show={true},
  title={symfinder: A toolchain for the identification and visualization of object-oriented variability implementations},
  author={Mortara, Johann and Tërnava, Xhevahire and Collet, Philippe},
  booktitle={23rd International Systems and Software Product Line Conference-Volume B},
  pages={5--8},
  year={2019},
  html = {https://doi.org/10.1145/3307630.3342394},
  doi = {10.1145/3307630.3342394},
  pdf={https://hal.archives-ouvertes.fr/hal-02342730/document},
  code={https://github.com/DeathStar3/symfinder},
  Website={https://deathstar3.github.io/symfinder-demo/},
  abstract = {When variability is implemented into a single variability-rich system with object-oriented techniques (e.g., inheritance, overloading, design patterns), the variation points and variants usually do not align with the domain features. It is then very hard and time consuming to manually identify these variation points to manage variability at the implementation level. symfinder is a toolchain to automatically identify and visualize these variability implementation locations inside a single object-oriented code base. For the identification part, it relies on the notion of symmetry between classes or methods to characterize uniformly some implementation techniques such as inheritance, overloading, or design patterns like Factory. The toolchain also generates an interactive Web-based visualization in which classes that are variation points are nodes linked together through their inheritance relationships, while the size, color, and texture of the nodes are used to represent some metrics on the number of overloaded constructors or methods. As a result, the visualization enables one to discern zones of interest where variation points are strongly present and to get relevant information over concerned classes. The toolchain, publicly available with its source code and an online demo, has been applied to several large open source projects.},
}

@inproceedings{ternava2019identifying,
  abbr={SPLC19},
  bibtex_show={true},
  title={Identifying and visualizing variability in object-oriented variability-rich systems},
  author={Tërnava, Xhevahire and Mortara, Johann and Collet, Philippe},
  booktitle={23rd International Systems and Software Product Line Conference-Volume A},
  pages={231--243},
  year={2019},
  html = {https://doi.org/10.1145/3336294.3336311},
  doi = {10.1145/3336294.3336311},
  pdf={https://hal.archives-ouvertes.fr/hal-02339296/document},
  code={https://github.com/DeathStar3/symfinder},
  Website={https://deathstar3.github.io/symfinder-demo/},
  badge={Awarded with the badge Reusable},
  blink={https://www.acm.org/publications/policies/artifact-review-badging},
  abstract = {In many variability-intensive systems, variability is implemented in code units provided by a host language, such as classes or functions, which do not align well with the domain features. Annotating or creating an orthogonal decomposition of code in terms of features implies extra effort, as well as massive and cumbersome refactoring activities. In this paper, we introduce an approach for identifying and visualizing the variability implementation places within the main decomposition structure of object-oriented code assets in a single variability-rich system. First, we propose to use symmetry, as a common property of some main implementation techniques, such as inheritance or overloading, to identify uniformly these places. We study symmetry in different constructs (e.g., classes), techniques (e.g., subtyping, overloading) and design patterns (e.g., strategy, factory), and we also show how we can use such symmetries to find variation points with variants. We then report on the implementation and application of a toolchain, symfinder, which automatically identifies and visualizes places with symmetry. The publicly available application to several large open-source systems shows that symfinder can help in characterizing code bases that are variability-rich or not, as well as in discerning zones of interest w.r.t. variability.},
}

@inproceedings{mortara2020mapping,
  abbr={VaMoS20},
  bibtex_show={true},
  title={Mapping features to automatically identified object-oriented variability implementations: The case of ArgoUML-SPL},
  author={Mortara, Johann and Tërnava, Xhevahire and Collet, Philippe},
  booktitle={14th International Working Conference on Variability Modelling of Software-Intensive Systems},
  pages={1--9},
  year={2020},
  html = {https://doi.org/10.1145/3377024.3377037},
  doi = {10.1145/3377024.3377037},
  pdf={https://hal.archives-ouvertes.fr/hal-02421353/document},
  supp={https://deathstar3.github.io/symfinder-demo/vamos2020/},
  code={https://github.com/DeathStar3/symfinder/tree/vamos2020},
  abstract = {In Software Product Line (SPL) engineering, mapping domain features to existing code assets is essential for variability management. When variability is already implemented through Object-Oriented (OO) techniques, it is too costly and error-prone to refactor assets in terms of features or to use feature annotations. In this work, we delve into the possible usage of automatically identified variation points with variants in an OO code base to enable feature mapping from the domain level. We report on an experiment conducted over ArgoUML-SPL, using its code as input for automatic detection through the symfinder toolchain, and the previously devised domain features as a ground truth. We analyse the relevance of the identified variation points with variants w.r.t. domain features, adapting precision and recall measures. This shows that the approach is feasible, that an automatic mapping can be envisaged, and also that the symfinder visualization is adapted to this process with some slight additions.},
}

@inproceedings{mortara2020identifying,
  abbr={SPLC20},
  bibtex_show={true},
  title={Identifying and Mapping Implemented Variabilities in Java and C++ systems using symfinder},
  author={Mortara, Johann and Collet, Philippe and Tërnava, Xhevahire},
  booktitle={24th ACM International Systems and Software Product Line Conference-Volume B},
  pages={9--12},
  year={2020},
  html = {https://doi.org/10.1145/3382026.3431251},
  doi = {10.1145/3382026.3431251},
  pdf={https://hal.archives-ouvertes.fr/hal-02908531/document},
  Website={https://deathstar3.github.io/symfinder-demo/splc2020.html},
  code={https://github.com/DeathStar3/symfinder/tree/splc2020},
  slides={https://www.youtube.com/watch?v=hkxuoc0Q2Rw},
  abstract = {Variability is present in most modern object-oriented softwareintensive systems, despite that they commonly do not follow a product line approach. In these systems, variability is implicit and hardly documented as it is implemented by different traditional mechanisms, namely inheritance, overloading, or design patterns. This hampers variability management as automatic identification of variation points (vp-s) with variants is very difficult. symfinder is a symmetry-based tooled approach that enables automatic identification of potential vp-s with variants in such systems. Then, it visualizes them relying on their density in code assets. From the Java-only version presented at SPLC'2019, we present here several notable improvements. They concern an added support for C++ systems, the identification of vp-s implemented by Decorator and Template pattern instances, an enhanced visualization (e.g., to display all variants, and package coloring), as well as automation of the mapping of potential vp-s to domain features.},
}

@article{ternava2020framework,
  abbr={COLA20},
  bibtex_show={true},
  title={A framework for managing the imperfect modularity of variability implementations},
  author={Tërnava, Xhevahire and Collet, Philippe},
  journal={Journal of Computer Languages},
  volume={61},
  pages={100998},
  year={2020},
  publisher={Elsevier},
  doi = {10.1016/j.cola.2020.100998},
  html = {https://www.sciencedirect.com/science/article/pii/S2590118420300587},
  pdf={https://hal.archives-ouvertes.fr/hal-02951745/document},
  supp={https://ternava.github.io/vm-dsl/},
  code={https://github.com/ternava/Variability-CChecking},
  award={First Runner-Up for the COLA Best Paper Award 2020},
  alink={https://www.sciencedirect.com/journal/journal-of-computer-languages/about/news/2020-best-paper-award-journal-of-computer-languages},
  abstract = {In many industrial settings, the common and varying features of related software-intensive systems, as their reusable units, are likely to be implemented by a combined set of traditional techniques. Features do not align perfectly well with the used language constructs, e.g., classes, thus hindering the management of implemented variability. Herein, we provide a detailed framework to capture, model, and trace this imperfectly modular variability in terms of variation points with variants. We describe an implementation of this framework, as a domain-specific language, and report on its application on four subject systems and usage for variability management, showing its feasibility.}
}

@inproceedings{lesoil2021interplay,
  abbr={SPLC21},
  bibtex_show={true},
  title={The interplay of compile-time and run-time options for performance prediction},
  author={Lesoil, Luc and Acher, Mathieu and Tërnava, Xhevahire and Blouin, Arnaud and Jézéquel, Jean-Marc},
  booktitle={25th ACM International Systems and Software Product Line Conference-Volume A},
  pages={100--111},
  year={2021},
  html = {https://doi.org/10.1145/3461001.3471149},
  doi = {10.1145/3461001.3471149},
  pdf={https://hal.archives-ouvertes.fr/hal-03286127/document},
  code={https://github.com/llesoil/ctime_opt},
  badge={Awarded with the badges Reusable, Available, and Reproducible},
  blink={https://www.acm.org/publications/policies/artifact-review-badging},
  abstract = {Many software projects are configurable through compile-time options (e.g., using ./configure) and also through run-time options (e.g., command-line parameters, fed to the software at execution time). Several works have shown how to predict the effect of run-time options on performance. However it is yet to be studied how these prediction models behave when the software is built with different compile-time options. For instance, is the best run-time configuration always the best w.r.t. the chosen compilation options? In this paper, we investigate the effect of compile-time options on the performance distributions of 4 software systems. There are cases where the compiler layer effect is linear which is an opportunity to generalize performance models or to tune and measure runtime performance at lower cost. We also prove there can exist an interplay by exhibiting a case where compile-time options significantly alter the performance distributions of a configurable system.},
}

@inproceedings{mortara2021extending,
  abbr={SPLC21},
  bibtex_show={true},
  title={Extending the identification of object-oriented variability implementations using usage relationships},
  author={Mortara, Johann and Tërnava, Xhevahire and Collet, Philippe and Pinna-Dery, Anne-Marie},
  booktitle={25th ACM International Systems and Software Product Line Conference-Volume B},
  pages={91--98},
  year={2021},
  html = {https://doi.org/10.1145/3461002.3473943},
  doi = {10.1145/3461002.3473943},
  pdf={https://hal.archives-ouvertes.fr/hal-03284626/document},
  Website={https://deathstar3.github.io/symfinder2-demo/},
  abstract = {Many variability-rich object-oriented systems rely on multiple traditional techniques (inheritance, patterns) to implement their variability in a single codebase. These variability implementation places are neither explicit nor documented, hampering their detection and variability comprehension. Based on the identification of symmetry property in seven implementation techniques, a first approach was proposed with symfinder to automatically identify and display the variability of a system in a graph-based visualization structured by inheritance. However, composition, or more generally the usage relationship, is extensively used to implement the variability in object-oriented systems, and without this information, comprehending the large amount of variability identified by symfinder is not trivial. In this paper, we present symfinder-2, an extension of the former approach that incorporates the usage relationships to better identify potential variability implementations. We provide two ways to mark classes as entry points, user-defined and automatic, so that the visualization is filtered and enables users to have a better focus when they identify variability. We also report on the evaluation of this extension to ten open-source Java-based systems.},
}

@inproceedings{ternava2022scratching,
  abbr={ICSR22},
  bibtex_show={true},
  title={Scratching the surface of./configure: Learning the effects of compile-time options on binary size and gadgets},
  author={Tërnava, Xhevahire and Acher, Mathieu and Lesoil, Luc and Blouin, Arnaud and Jézéquel, Jean-Marc},
  booktitle={The International Conference on Software and Systems Reuse},
  year={2022},
  doi={10.1007/978-3-031-08129-3_3},
  html={https://doi.org/10.1007/978-3-031-08129-3_3},
  pdf={https://hal.archives-ouvertes.fr/hal-03627246/document},
  supp={https://github.com/diverse-project/confsurface},
  award={Best Paper Award},
  alink={https://twitter.com/GPerrouin/status/1537799049000140800?s=20&t=1QNCn1d3G5EJCBbOX-byAw},
  abstract={Numerous software systems are configurable through compile-time options and the widely used ./configure. However, the combined effects of these options on binary's non-functional properties (size and attack surface) are often not documented, and or not well understood, even by experts. Our goal is to provide automated support for exploring and comprehending the configuration space (a.k.a., surface) of compile-time options using statistical learning techniques. In this paper, we perform an empirical study on four C-based configurable systems. We measure the variation of binary size and attack surface (by quantifying the number of code reuse gadgets) in over 400 compile-time configurations of a subject system. We then apply statistical learning techniques on top of our build infrastructure to identify how compile-time options relate to non-functional properties. Our results show that, by changing the default configuration, the system's binary size and gadgets vary greatly (roughly −79% to 244% and −77% to 30%, respectively). Then, we found out that identifying the most influential options can be accurately learned with a small training set, while their relative importance varies across size and attack surface for the same system. Practitioners can use our approach and artifacts to explore the effects of compile-time options in order to take informed decisions when configuring a system with ./configure.},
}

@inproceedings{aaron2022,
  abbr={ICSE22},
  bibtex_show={true},
  title={On the benefits and limits of incremental build of software configurations: An exploratory study},
  author={Randrianaina, Georges Aaron and Tërnava, Xhevahire and Khelladi, Djamel Eddine and Acher, Mathieu},
  booktitle={44th International Conference on Software Engineering},
  pages     = {1584--1596},
  publisher = {{IEEE}},
  year      = {2022},
  html       = {https://ieeexplore.ieee.org/document/9793946},
  doi       = {10.1145/3510457.3513035},
  pdf={https://hal.archives-ouvertes.fr/hal-03547219v3/document},
  supp={https://zenodo.org/record/5917570#.YrHnX9JBxB8},
  badge={Awarded with the badges Reusable and Available},
  blink={https://www.acm.org/publications/policies/artifact-review-badging},
  abstract={Software projects use build systems to automate the compilation, testing, and continuous deployment of their software products. As software becomes increasingly configurable, the build of multiple configurations is a pressing need, but expensive and challenging to implement. The current state of practice is to build independently (a.k.a., clean build) a software for a subset of configurations. While incremental build has been studied for software evolution and relatively small changes of the source code, it has surprisingly not been considered for software configurations. In this exploratory study, we examine the benefits and limits of building software configurations incrementally, rather than always building them cleanly. By using five real-life configurable systems as subjects, we explore whether incremental build works, outperforms a sequence of clean builds, is correct w.r.t. clean build, and can be used to find an optimal ordering for building configurations. Our results show that incremental build is feasible in 100% of the times in four subjects and in 78% of the times in one subject. In average, 88.5% of the configurations could be built faster with incremental build while also finding several alternatives faster incremental builds. However, only 60% of faster incremental builds are correct. Still, when considering those correct incremental builds with clean builds, we could always find an optimal order that is faster than just a collection of clean builds with a gain up to 11.76%.},
}

@article{ternava2022,
  abbr={ASE22},
  bibtex_show={true},
  title={Identification and visualization of variability implementations in object-oriented variability-rich systems: A symmetry-based approach},
  author={Tërnava, Xhevahire and Mortara, Johann and Collet, Philippe and Berre, Daniel Le},
  journal={Automated Software Engineering},
  volume={29},
  number={1},
  pages={1--51},
  year={2022},
  publisher={Springer},
  html={https://doi.org/10.1007/s10515-022-00329-x},
  doi={10.1007/s10515-022-00329-x},
  pdf={https://hal.archives-ouvertes.fr/hal-03593967/document},
  code={https://github.com/DeathStar3/symfinder},
  Website={https://deathstar3.github.io/symfinder-demo/jrn20.html},
  abstract={Most modern object-oriented software systems are variability-rich, despite that they may not be developed as product lines. Their variability is implemented by several traditional techniques in combination, such as inheritance, overloading, or design patterns. As domain features or variation points with variants are not a by-product of these techniques, variability in code assets of such systems is implicit, and hardly documented, hampering qualities such as understandability and maintainability. In this article, we present an approach for automatic identification and visualization of variability implementation places, that is, variation points with variants, in variability-rich systems. To uniformly identify them, we propose to rely on the existing symmetries in the different software constructs and patterns. We then propose to visualize them according to their density. By means of our realized toolchain implementing the approach, symfinder, we report on a threefold evaluation, (i) on the identified potential variability in sixteen large open-source systems and symfinder ’s scalability, (ii) on measuring symfinder ’s precision and robustness when mapping identified variability to domain features, and (iii) on its usage by a software architect. Results show that symfinder can indeed help in identifying and comprehending the variability of the targeted systems.},
}

@inproceedings{ternava2022interaction,
  abbr={VaMoS22},
  bibtex_show={true},
  title={On the interaction of feature toggles},
  author={Tërnava, Xhevahire and Lesoil, Luc and Randrianaina, Georges Aaron and Khelladi, Djamel Eddine and Acher, Mathieu},
  booktitle={16th International Working Conference on Variability Modelling of Software-Intensive Systems},
  pages={1--5},
  year={2022},
  html = {https://doi.org/10.1145/3510466.3510485},
  doi = {10.1145/3510466.3510485},
  pdf={https://hal.archives-ouvertes.fr/hal-03527250v2/document},
  supp={https://github.com/llesoil/poc_ftm},
  abstract = {Feature toggling is a technique for enabling branching-in-code. It is increasingly used during continuous deployment to incrementally test and integrate new features before their release. In principle, feature toggles tend to be light, that is, they are defined as simple Boolean flags and used in conditional statements to condition the activation of some software features. However, there is a lack of knowledge on whether and how they may interact with each other, in that case their enabling and testing become complex. We argue that finding the interactions of feature toggles is valuable for developers to know which of them should be enabled at the same time, which are impacted by a removed toggle, and to avoid their mis-configurations. In this work, we mine feature toggles and their interactions in five open-source projects. We then analyse how they are realized and whether they tend to be multiplied over time. Our results show that 7% of feature toggles interact with each other, 33% of them interact with another code expression, and their interactions tend to increase over time (22%, on average). Further, their interactions are expressed by simple logical operators (i.e., and and or) and nested if statements. We propose to model them into a Feature Toggle Model, and believe that our results are helpful towards robust management approaches of feature toggles.},
}
@inproceedings{ternava2023remove,
  abbr={VaMoS23},
  bibtex_show={true},
  title={A call for removing variability},
  author={Acher, Mathieu and Lesoil, Luc and Randrianaina, Georges Aaron and Tërnava, Xhevahire and Zendra, Olivier},
  booktitle={17th International Working Conference on Variability Modelling of Software-Intensive Systems},
  pages={1--3},
  year={2023},
  html = {https://doi.org/10.1145/3571788.3571801},
  slides = {VaMoS23_Presentation.pdf},
  doi = {10.1145/3571788.3571801},
  pdf= {https://hal.science/hal-03882594/document},
  abstract = {Software variability is largely accepted and explored in software engineering and seems to have become a norm and a must, if only in the context of product lines. Yet, the removal of superfluous or unneeded software artefacts and functionalities is an inevitable trend. It is frequently investigated in relation to software bloat. This paper is essentially a call to the community on software variability to devise methods and tools that will facilitate the removal of unneeded variability from software systems. The advantages are expected to be numerous in terms of functional and non-functional properties, such as maintainability (lower complexity), security (smaller attack surface), reliability, and performance (smaller binaries).},
}
@inproceedings{ternava2022specialization,
  abbr={arXiv22},
  bibtex_show={true},
  title={Specialization of run-time configuration space at compile-time: An exploratory study},
  author={Tërnava, Xhevahire and Acher, Mathieu and Combemale, Benoit},
  booktitle={arXiv preprint arXiv:2210.14082},
  pages={1--14},
  year={2022},
  html = {https://doi.org/10.48550/arXiv.2210.14082},
  doi = {10.48550/arXiv.2210.14082},
  pdf={https://arxiv.org/pdf/2210.14082.pdf},
  abstract = {Numerous software systems are highly configurable through run-time options, such as command-line parameters. Users can tune some of the options to meet various functional and non-functional requirements such as footprint, security, or execution time. However, some options are never set for a given system instance, and their values remain the same whatever the use cases of the system. Herein, we design a controlled experiment in which the system's run-time configuration space can be specialized at compile-time and combinations of options can be removed on demand. We perform an in-depth study of the well-known x264 video encoder and quantify the effects of its specialization to its non-functional properties, namely on binary size, attack surface, and performance while ensuring its validity. Our exploratory study suggests that the configurable specialization of a system has statistically significant benefits on most of its analysed non-functional properties, which benefits depend on the number of the debloated options. While our empirical results and insights show the importance of removing code related to unused run-time options to improve software systems, an open challenge is to further automate the specialization process.},
}
@inproceedings{ternava2022specialization2,
  abbr={SAC23},
  bibtex_show={true},
  title={Specialization of run-time configuration space at compile-time: An exploratory study},
  author={Tërnava, Xhevahire and Acher, Mathieu and Combemale, Benoit},
  booktitle={38th ACM/SIGAPP Symposium on Applied Computing},
  pages={1--10},
  year={2023},
  html = {https://doi.org/10.1145/3555776.3578613},
  doi = {10.1145/3555776.3578613},
  pdf={https://hal.archives-ouvertes.fr/hal-03916459},
  abstract = {Numerous software systems are highly configurable through runtime options (e.g., command-line parameters). Users can tune some of the options to meet various functional and non-functional requirements such as footprint, security, or execution time. However, some options are never set for a given system instance, and their values remain the same whatever the use cases of the system. Herein, we design a controlled experiment in which the system's run-time configuration space can be specialized at compile-time and combinations of options can be removed on demand. We perform an in-depth study of the well-known x264 video encoder and quantify the effects of its specialization to its non-functional properties, namely on binary size, attack surface, and performance while ensuring its validity. Our exploratory study suggests that the configurable specialization of a system has statistically significant benefits on most of its analysed non-functional properties, which benefits depend on the number of the debloated options. While our empirical results and insights show the importance of removing code related to unused run-time options to improve software systems, an open challenge is to further automate the specialization process.},
}
  pdf={https://hal.archives-ouvertes.fr/hal-03916459},
  abstract = {Numerous software systems are highly configurable through runtime options (e.g., command-line parameters). Users can tune some of the options to meet various functional and non-functional requirements such as footprint, security, or execution time. However, some options are never set for a given system instance, and their values remain the same whatever the use cases of the system. Herein, we design a controlled experiment in which the system's run-time configuration space can be specialized at compile-time and combinations of options can be removed on demand. We perform an in-depth study of the well-known x264 video encoder and quantify the effects of its specialization to its non-functional properties, namely on binary size, attack surface, and performance while ensuring its validity. Our exploratory study suggests that the configurable specialization of a system has statistically significant benefits on most of its analysed non-functional properties, which benefits depend on the number of the debloated options. While our empirical results and insights show the importance of removing code related to unused run-time options to improve software systems, an open challenge is to further automate the specialization process.},
}

@inproceedings{ternava2025effect,
  abbr={SPLC25},
  title={On the effect of feature reduction on energy consumption: An exploratory study},
  author={Tërnava, Xhevahire and Lefeuvre, Romain and Perez, Quentin and Khelladi, Djamel Eddine and Acher, Mathieu and Combemale, Benoit},
  year={2025},
  html = {https://doi.org/10.1145/3744915.3748463},
  doi = {10.1145/3744915.3748463},
  pdf={https://hal.science/hal-05166140/},
  abstract = {Energy consumption is a growing concern for sustainable software. Although increasingly studied, it remains largely unexplored in configurable systems growing in complexity with features. Feature reduction can eliminate software bloat, but to our knowledge, its impact on energy use has not been investigated. To fill this gap, we investigated how both on-demand and built-in feature reduction (defined later) affect the energy consumption of configurable systems. We conducted a first exploratory study using 28 programs from three systems with built-in feature reduction, namely ToyBox, BusyBox, and GNU, as well as 6 GNU programs debloated on-demand using the Chisel, Debop, and Cov tools. In our results, built-in feature reduction led to statistically significant energy decreases in 7% of the cases, while on-demand reduction, despite achieving energy decreases in 67% of cases, showed no statistical significance. However, when energy consumption increased, it was often more substantial than the reductions observed (occurring in 25% of built-in cases and 11% of on-demand cases) showing the complex and sometimes counterintuitive interplay between feature reduction and energy. Additionally, the observed strong correlation between energy consumption and execution time motivates a shift from traditional debloating goals, centered on binary size/attack surface, to energy-aware strategies that prioritize performance concerns. Finally, we provide an in-depth analysis and discuss the perspective.}
}
@article{ternava2025small,
  abbr={preprint},
  title={Small yet configurable: Unveiling null variability in software},
  author={Tërnava, Xhevahire and Randrianaina, Georges Aaron and Lesoil, Luc and Acher, Mathieu},
  year={2025},
  html = {https://hal.science/hal-05097580},
  pdf={https://hal.science/hal-05097580},
  abstract = {Many small-scale software systems, that is, with limited codebase or binary size, are widely used in everyday tasks, yet their configurability remains largely unexplored. At the same time, studies on modern software systems show a trend toward increasing configurability, alongside growing interest in building immutable, specialized, and reproducible software. In this paper, we present the first empirical study on the extent of configurability in small-scale software systems. By analyzing 108 programs from GNU coreutils, we show that even small programs can exhibit significant compile-time and run-time variability, with up to 76 options per program. Then, there is a high correlation (0.78) between run-time variability and codebase size. Furthermore, an analysis of the 20 smallest programs across 85 releases reveals that variability tends to increase over time, primarily due to the added compile-time variability. This suggests that shifting options between run-time and compile-time, removing unnecessary run-time variability, or resolving compile-time variability early, can help reduce codebase complexity and size. We also introduce, for the first time, the concept of null-variable software system, one with no configurability beyond mandatory features. Our findings show that high configurability is not exclusive to largescale systems and that reducing unnecessary variability can lead to lightweight, smaller, and more maintainable software. We hope this effort contributes to designing new software by understanding how to balance its configurability with codebase size.},
}